import { decoder } from '../lib/buffer_utils.mjs';
import { encode, decode } from '../runtime/base64url.mjs';
import { JWTInvalid } from '../util/errors.mjs';
import jwtPayload from '../lib/jwt_claims_set.mjs';
import ProduceJWT from '../lib/jwt_producer.mjs';

class UnsecuredJWT extends ProduceJWT {
    encode() {
        const header = encode(JSON.stringify({ alg: 'none' }));
        const payload = encode(JSON.stringify(this._payload));
        return `${header}.${payload}.`;
    }
    static decode(jwt, options) {
        if (typeof jwt !== 'string') {
            throw new JWTInvalid('Unsecured JWT must be a string');
        }
        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split('.');
        if (length !== 3 || signature !== '') {
            throw new JWTInvalid('Invalid Unsecured JWT');
        }
        let header;
        try {
            header = JSON.parse(decoder.decode(decode(encodedHeader)));
            if (header.alg !== 'none')
                throw new Error();
        }
        catch {
            throw new JWTInvalid('Invalid Unsecured JWT');
        }
        const payload = jwtPayload(header, decode(encodedPayload), options);
        return { payload, header };
    }
}

export default UnsecuredJWT;
export { UnsecuredJWT };
