import { promisify } from 'util';
import { pbkdf2 as pbkdf2$1, randomFillSync } from 'crypto';
import { p2s } from '../lib/buffer_utils.mjs';
import { encode } from './base64url.mjs';
import { unwrap, wrap } from './aeskw.mjs';
import checkP2s from '../lib/check_p2s.mjs';
import { isCryptoKey as impl, getKeyObject } from './webcrypto.mjs';
import isKeyObject from './is_key_object.mjs';

const pbkdf2 = promisify(pbkdf2$1);
function getPassword(key, alg) {
    if (isKeyObject(key)) {
        return key.export();
    }
    if (key instanceof Uint8Array) {
        return key;
    }
    if (impl(key)) {
        return getKeyObject(key, alg, new Set(['deriveBits', 'deriveKey'])).export();
    }
    throw new TypeError('invalid key input');
}
const encrypt = async (alg, key, cek, p2c = Math.floor(Math.random() * 2049) + 2048, p2s$1 = randomFillSync(new Uint8Array(16))) => {
    checkP2s(p2s$1);
    const salt = p2s(alg, p2s$1);
    const keylen = parseInt(alg.substr(13, 3), 10) >> 3;
    const password = getPassword(key, alg);
    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.substr(8, 3)}`);
    const encryptedKey = await wrap(alg.substr(-6), derivedKey, cek);
    return { encryptedKey, p2c, p2s: encode(p2s$1) };
};
const decrypt = async (alg, key, encryptedKey, p2c, p2s$1) => {
    checkP2s(p2s$1);
    const salt = p2s(alg, p2s$1);
    const keylen = parseInt(alg.substr(13, 3), 10) >> 3;
    const password = getPassword(key, alg);
    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.substr(8, 3)}`);
    return unwrap(alg.substr(-6), derivedKey, encryptedKey);
};

export { decrypt, encrypt };
