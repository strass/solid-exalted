import { generateKeyPair as generateKeyPair$1, diffieHellman } from 'crypto';
import { promisify } from 'util';
import getNamedCurve from './get_named_curve.mjs';
import { concatKdf, concat, uint32be, lengthAndInput, encoder } from '../lib/buffer_utils.mjs';
import digest from './digest.mjs';
import { JOSENotSupported } from '../util/errors.mjs';
import { isCryptoKey as impl, getKeyObject } from './webcrypto.mjs';
import isKeyObject from './is_key_object.mjs';

const generateKeyPair = promisify(generateKeyPair$1);
const deriveKey = async (publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) => {
    const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));
    if (impl(publicKey)) {
        publicKey = getKeyObject(publicKey, 'ECDH-ES');
    }
    if (!isKeyObject(publicKey)) {
        throw new TypeError('invalid key input');
    }
    if (impl(privateKey)) {
        privateKey = getKeyObject(privateKey, 'ECDH-ES', new Set(['deriveBits', 'deriveKey']));
    }
    if (!isKeyObject(privateKey)) {
        throw new TypeError('invalid key input');
    }
    const sharedSecret = diffieHellman({ privateKey, publicKey });
    return concatKdf(digest, sharedSecret, keyLength, value);
};
const generateEpk = async (key) => {
    if (impl(key)) {
        key = getKeyObject(key);
    }
    if (!isKeyObject(key)) {
        throw new TypeError('invalid key input');
    }
    switch (key.asymmetricKeyType) {
        case 'x25519':
            return (await generateKeyPair('x25519')).privateKey;
        case 'x448': {
            return (await generateKeyPair('x448')).privateKey;
        }
        case 'ec': {
            const namedCurve = getNamedCurve(key);
            return (await generateKeyPair('ec', { namedCurve })).privateKey;
        }
        default:
            throw new JOSENotSupported('unsupported or invalid EPK');
    }
};
const ecdhAllowed = (key) => ['P-256', 'P-384', 'P-521', 'X25519', 'X448'].includes(getNamedCurve(key));

export { deriveKey, ecdhAllowed, generateEpk };
