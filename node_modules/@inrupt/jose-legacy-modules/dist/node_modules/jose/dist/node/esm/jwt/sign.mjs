import { CompactSign } from '../jws/compact/sign.mjs';
import { JWTInvalid } from '../util/errors.mjs';
import { encoder } from '../lib/buffer_utils.mjs';
import ProduceJWT from '../lib/jwt_producer.mjs';

class SignJWT extends ProduceJWT {
    setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
    }
    async sign(key, options) {
        var _a;
        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (((_a = this._protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes('b64')) && this._protectedHeader.b64 === false) {
            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');
        }
        return sig.sign(key, options);
    }
}

export default SignJWT;
export { SignJWT };
