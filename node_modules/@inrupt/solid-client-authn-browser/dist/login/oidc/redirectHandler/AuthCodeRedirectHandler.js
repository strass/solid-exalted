"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthCodeRedirectHandler = exports.DEFAULT_LIFESPAN = void 0;
const tsyringe_1 = require("tsyringe");
const oidc_client_ext_1 = require("@inrupt/oidc-client-ext");
const fetchFactory_1 = require("../../../authenticatedFetch/fetchFactory");
const constant_1 = require("../../../constant");
exports.DEFAULT_LIFESPAN = 30 * 60 * 1000;
async function setupResourceServerSession(webId, authenticatedFetch, storageUtility) {
    const webIdAsUrl = new URL(webId);
    const resourceServerIri = webIdAsUrl.origin;
    await authenticatedFetch(webId);
    try {
        const resourceServerResponse = await authenticatedFetch(`${resourceServerIri}/session`);
        if (resourceServerResponse.status === 200) {
            await storageUtility.storeResourceServerSessionInfo(webId, resourceServerIri, Date.now() + exports.DEFAULT_LIFESPAN);
            return;
        }
        await storageUtility.clearResourceServerSessionInfo(resourceServerIri);
    }
    catch (_e) {
        await storageUtility.clearResourceServerSessionInfo(resourceServerIri);
    }
}
let AuthCodeRedirectHandler = class AuthCodeRedirectHandler {
    constructor(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar) {
        this.storageUtility = storageUtility;
        this.sessionInfoManager = sessionInfoManager;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
    }
    async canHandle(redirectUrl) {
        try {
            const myUrl = new URL(redirectUrl);
            return (myUrl.searchParams.get("code") !== null &&
                myUrl.searchParams.get("state") !== null);
        }
        catch (e) {
            throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e.toString()}`);
        }
    }
    async handle(redirectUrl) {
        if (!(await this.canHandle(redirectUrl))) {
            throw new Error(`AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`);
        }
        const url = new URL(redirectUrl);
        const oauthState = url.searchParams.get("state");
        const storedSessionId = (await this.storageUtility.getForUser(oauthState, "sessionId", {
            errorIfNull: true,
        }));
        const isDpop = (await this.storageUtility.getForUser(storedSessionId, "dpop")) ===
            "true";
        const issuer = (await this.storageUtility.getForUser(storedSessionId, "issuer", { errorIfNull: true }));
        window.localStorage.setItem(constant_1.KEY_CURRENT_SESSION, storedSessionId);
        const issuerConfig = await this.issuerConfigFetcher.fetchConfig(issuer);
        const client = await this.clientRegistrar.getClient({ sessionId: storedSessionId }, issuerConfig);
        let tokens;
        let authFetch;
        const referenceTime = Date.now();
        if (isDpop) {
            const codeVerifier = (await this.storageUtility.getForUser(storedSessionId, "codeVerifier", { errorIfNull: true }));
            const storedRedirectIri = (await this.storageUtility.getForUser(storedSessionId, "redirectUrl", { errorIfNull: true }));
            tokens = await oidc_client_ext_1.getDpopToken(issuerConfig, client, {
                grantType: "authorization_code",
                code: url.searchParams.get("code"),
                codeVerifier,
                redirectUrl: storedRedirectIri,
            });
            authFetch = await fetchFactory_1.buildDpopFetch(tokens.accessToken, tokens.dpopKey);
        }
        else {
            tokens = await oidc_client_ext_1.getBearerToken(url.toString());
            authFetch = fetchFactory_1.buildBearerFetch(tokens.accessToken);
        }
        await this.storageUtility.setForUser(storedSessionId, {
            refreshToken: "<Refresh token that *is* coming back in the redirect URL is not yet being parsed and provided by oidc-client-js in it's response object>",
            webId: tokens.webId,
            isLoggedIn: "true",
        }, { secure: true });
        url.searchParams.delete("code");
        await this.storageUtility.setForUser(storedSessionId, {
            redirectUrl: url.toString(),
            idToken: tokens.idToken,
        }, {
            secure: false,
        });
        const essWorkaroundDisabled = window.localStorage.getItem("tmp-resource-server-session-enabled") ===
            "false";
        if (!essWorkaroundDisabled) {
            await setupResourceServerSession(tokens.webId, authFetch, this.storageUtility);
        }
        const sessionInfo = await this.sessionInfoManager.get(storedSessionId);
        if (!sessionInfo) {
            throw new Error(`Could not retrieve session: [${storedSessionId}].`);
        }
        return Object.assign(sessionInfo, {
            fetch: authFetch,
            expirationDate: typeof tokens.expiresIn === "number"
                ? referenceTime + tokens.expiresIn * 1000
                : null,
        });
    }
};
AuthCodeRedirectHandler = __decorate([
    tsyringe_1.injectable(),
    __param(0, tsyringe_1.inject("browser:storageUtility")),
    __param(1, tsyringe_1.inject("browser:sessionInfoManager")),
    __param(2, tsyringe_1.inject("browser:issuerConfigFetcher")),
    __param(3, tsyringe_1.inject("browser:clientRegistrar")),
    __metadata("design:paramtypes", [Object, Object, Object, Object])
], AuthCodeRedirectHandler);
exports.AuthCodeRedirectHandler = AuthCodeRedirectHandler;
//# sourceMappingURL=AuthCodeRedirectHandler.js.map